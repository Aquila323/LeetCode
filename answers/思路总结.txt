

206.反转链表
需要注意，反转链表不只是要改变节点里的值，需要对节点本身的链表顺序做翻转

题解：维护三个指针，分别指向previous、current、next
每次修改curNode.next的指针指向，然后将三个指针依次后移，直到curNode==null，
不要忘就修改最后一个节点的next指针




25. K 个一组翻转链表
链表结构只有通过遍历才能确认数量，因此K个节点的遍历是无法避免的

题解：维护两个指针start和end，每次定位start作为上一组的尾节点，end作为下一组的首节点
start~end之间的节点即作为需要翻转的节点组，end前一个节点的next设置为null作为分隔符
定义一个子函数，用于翻转一组节点，从start+1开始，到null结束，返回新节点的节点头




160. 相交链表
判断两条链表是否相交并且相交后的尾部节点都相同

题解一：首先遍历一条链表，将全部节点加入到HashSet中，再遍历另一链表，使用hashset.contains()判断是否存在
不同节点的引用值不同，因此节点Hash不同，但节点里的value有可能相同，所以要是用节点本身做Hash而非value
这样做的优点是每条链表只需单次遍历即可完成查找，但是创建HashMap需要花费空间复杂度O(N)

题解二：（相当精巧）链表AB，两条链表的数量可能不同，但同时遍历A+B和B+A则可以保证两条线路遍历的节点数量相同
第二次遍历到公共段时，节点就会相交，如图所示
	AAAAAAAAAACCCCC(null)BBBBBBBBBBBBBBBBCCCCC(null)
	BBBBBBBBBBBBBBBBCCCCC(null)AAAAAAAAAACCCCC(null)
								   ----- 最后这段CCCCC位置相同
表达式：
  while (pA != pB) {
	pA = pA!=null ? pA.next : headB;
	pB = pB!=null ? pB.next : headA;
  }
这样的写法并不会导致死循环，因为当两段不相交的链表同时到达尾部null节点时也会满足pA==pB，
所以不管链表本身什么样，A+B的遍历一次必然会结束循环



215. 数组中的第K个最大元素




53. 最大子数组和
典型的动态规划算法，Sn表示包含第n个元素时当前最大的子序和。
如果用Sn表示到第n个元素时当前最大子序（而不确定是否包含n），则无法写出递归等式。



146. LRU缓存机制






15. 三数之和
主要问题是数组中存在重复元素，因此不适合HashMap查找。

题解：双指针法，
i从零开始遍历0~n-1，在i后面设定L和R指针，L=i+1，R=n-1
nums[i] + nums[L] + nums[R] == 0
L到R之间偏移指针，如果大了就把R往左移动，小了就把L往右移动。
需要先排序，再查找，时间复杂度=O(nlogn) + O(n^2)


1. 两数之和
题目描述很简单，但实际使用了HashMap储存键值对唯一的特性，和数组初始化

题解：使用HashMap存储已访问过的数组元素，元素值和下标分别作为<key, value>
每次查询一个数组元素时，先看该元素在Map中是否存在对应的目标值，如果存在就直接返回结果
如果Map中不存在对应的目标值，则将本次访问的元素加入Map


3. 无重复字符的最长子串
我自己写的是维护String来记录子串，操作起来麻烦，而且空间、时间花费都更高

题解：滑动窗口思路，维护一个左指针，到最新访问的节点细节之间就是当前字符串窗口。
使用HashMap记录已浏览过的字符值和位置<char, pos>，如果最右指针元素和Map重复了，就把左指针向右移
每次右移都更新Map字典
注意：只有left指针右侧的位置值是有效的、非重复的




121. 买卖股票的最佳时机
这提示我最早刷LeetCode就会的题，只需维护一个maxProfit和一个minPrice，一次遍历即可找到最大盈利




21. 合并两个有序链表
控制好边界条件就行，比较容易，没有特殊算法




113. 路径总和 II
题目要求的路径必须是完整路径，从根节点到叶子节点，所以查找结果必须是包含完整的叶子结点。
尝试所有可能的基本思路还是递归，或者通过栈实现迭代，BFS或DFS均可。






236. 二叉树的最近公共祖先
最近的公共祖先的特点：
1.左子树和右子树都各自包含一个目标节点
2.节点本身就是一个目标节点，并且左子树或右子树中包含另一个节点

使用递归法，满足条件的就是最近公共祖先





958. 二叉树的完全性检验
使用队列实现广度优先遍历，检查每个节点：从队列取出一个节点，如果取出为空，则遍历已完成，返回true
若节点非空，则把左右子节点分别加入队列，继续循环取队列。
当遇到第一个子节点（左右都算）为空的节点时，置flag为true，表示这之后队列中的所有节点都不应再有子节点。






102. 二叉树的层序遍历
通过链表方式实现广度优先遍历，访问一个节点时，将其左右子节点加入到队列
由于输出是每行一个数组打印，因此浏览时需要记录当前层中节点个数，以控制数组创建时机






103. 二叉树的锯齿形层序遍历

与广度优先遍历类似，每行遍历完成后需要将偶数行数据顺序反转







105. 从前序与中序遍历序列构造二叉树

递归方式构造二叉树，使用Arrays.copyOfRange方便的创造子数组


41. 缺失的第一个正数a
非常巧妙的解法
题目中要求时间复杂度为O(N)，空间复杂度O(1)，想创建任何能存放N个元素的数据结构都会导致空间复杂度超出要求，
因此本题试图通过在原数组中进行特殊标记来记录访问状态

数组中一共N个元素，如果存在至少一个非正数或大于N的正数，则[1, N]这其中N个数字一定会有缺失。
非正数和大于N的数一样，其价值是相同的，都不需要关注，只需关注[1, N]这个范围内的数字
将[1, N]一一映射到[0, N-1]上，就可以通过数组坐标表示存在与否的状态，思路就是给所有元素值加上一个“负号”
最后遍历整个数组，所有位置上的元素，如果是负数，就说明这个元素的下标加一以后，存在于数组中
反之，如果出现了小于N+1的正数，则说明这个数加一以后不存在于数组中

解题步骤：
1.遍历数组，将所有小于等于0的元素都修改成N+1，此时数组中仅存在正整数
2.遍历数组，对于值为[1, N]范围内的元素K，在数组中的K-1位置标记一个负号
3.遍历数组，如果元素值为正数，则表示这个坐标(i)对应的元素值(i+1)没出现过，就是答案




199. 二叉树的右视图
注意：LeetCode的时间消耗排名和内训消耗排名不准确，不能作为判断时间复杂度、空间复杂的的标准

ArrayDeque和LinkedList的区别
执行用时：1 ms-.73%
内存消耗：40.1 MB-57.14%

题解：BFS逐层遍历二叉树，将每层最后一个节点的值记录下来即可



54. 螺旋矩阵
是一道数学题，主要难度是边界判断和计算旋转路线。




101. 对称二叉树
递归法，很容易



415. 字符串相加
涉及String和int相互转化，数字按照String按位从尾加到头部，完成后再使用str.reverse()进行反转




232. 用栈实现队列
使用两个栈，分别用于入栈缓存和出栈，
pop时，如果出栈为空，则将数据从入栈倒换至出栈，这样倒换一次顺序就实现了队列的先入先出

考虑泛型实现




112. 路径总和

看似简单，实则具有启发性
可以通过递归法进行BFS或DFS，也可以用队列实现BFS/栈实现DFS
值得认真写一写

思考本题和《113. 路径总和 II》有什么区别








