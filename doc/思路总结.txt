

206.反转链表
需要注意，反转链表不只是要改变节点里的值，需要对节点本身的链表顺序做翻转

题解：维护三个指针，分别指向previous、current、next
每次修改curNode.next的指针指向，然后将三个指针依次后移，直到curNode==null，
不要忘就修改最后一个节点的next指针




25. K 个一组翻转链表
链表结构只有通过遍历才能确认数量，因此K个节点的遍历是无法避免的

题解：维护两个指针start和end，每次定位start作为上一组的尾节点，end作为下一组的首节点
start~end之间的节点即作为需要翻转的节点组，end前一个节点的next设置为null作为分隔符
定义一个子函数，用于翻转一组节点，从start+1开始，到null结束，返回新节点的节点头




160. 相交链表
判断两条链表是否相交并且相交后的尾部节点都相同

题解一：首先遍历一条链表，将全部节点加入到HashSet中，再遍历另一链表，使用hashset.contains()判断是否存在
不同节点的引用值不同，因此节点Hash不同，但节点里的value有可能相同，所以要是用节点本身做Hash而非value
这样做的优点是每条链表只需单次遍历即可完成查找，但是创建HashMap需要花费空间复杂度O(N)

题解二：（相当精巧）链表AB，两条链表的数量可能不同，但同时遍历A+B和B+A则可以保证两条线路遍历的节点数量相同
第二次遍历到公共段时，节点就会相交，如图所示
	AAAAAAAAAACCCCC(null)BBBBBBBBBBBBBBBBCCCCC(null)
	BBBBBBBBBBBBBBBBCCCCC(null)AAAAAAAAAACCCCC(null)
								   ----- 最后这段CCCCC位置相同
表达式：
  while (pA != pB) {
	pA = pA!=null ? pA.next : headB;
	pB = pB!=null ? pB.next : headA;
  }
这样的写法并不会导致死循环，因为当两段不相交的链表同时到达尾部null节点时也会满足pA==pB，
所以不管链表本身什么样，A+B的遍历一次必然会结束循环



215. 数组中的第K个最大元素




53. 最大子数组和
典型的动态规划算法，Sn表示包含第n个元素时当前最大的子序和。
如果用Sn表示到第n个元素时当前最大子序（而不确定是否包含n），则无法写出递归等式。



146. LRU缓存机制






15. 三数之和
主要问题是数组中存在重复元素，因此不适合HashMap查找。

题解：双指针法，
i从零开始遍历0~n-1，在i后面设定L和R指针，L=i+1，R=n-1
nums[i] + nums[L] + nums[R] == 0
L到R之间偏移指针，如果大了就把R往左移动，小了就把L往右移动。
需要先排序，再查找，时间复杂度=O(nlogn) + O(n^2)


1. 两数之和
题目描述很简单，但实际使用了HashMap储存键值对唯一的特性，和数组初始化

题解：使用HashMap存储已访问过的数组元素，元素值和下标分别作为<key, value>
每次查询一个数组元素时，先看该元素在Map中是否存在对应的目标值，如果存在就直接返回结果
如果Map中不存在对应的目标值，则将本次访问的元素加入Map


3. 无重复字符的最长子串
我自己写的是维护String来记录子串，操作起来麻烦，而且空间、时间花费都更高

题解：滑动窗口思路，维护一个左指针，到最新访问的节点细节之间就是当前字符串窗口。
使用HashMap记录已浏览过的字符值和位置<char, pos>，如果最右指针元素和Map重复了，就把左指针向右移
每次右移都更新Map字典
注意：只有left指针右侧的位置值是有效的、非重复的




121. 买卖股票的最佳时机
这提示我最早刷LeetCode就会的题，只需维护一个maxProfit和一个minPrice，一次遍历即可找到最大盈利




21. 合并两个有序链表
控制好边界条件就行，比较容易，没有特殊算法




113. 路径总和 II
题目要求的路径必须是完整路径，从根节点到叶子节点，所以查找结果必须是包含完整的叶子结点。
尝试所有可能的基本思路还是递归，或者通过栈实现迭代，BFS或DFS均可。






236. 二叉树的最近公共祖先
最近的公共祖先的特点：
1.左子树和右子树都各自包含一个目标节点
2.节点本身就是一个目标节点，并且左子树或右子树中包含另一个节点

使用递归法，满足条件的就是最近公共祖先





958. 二叉树的完全性检验
使用队列实现广度优先遍历，检查每个节点：从队列取出一个节点，如果取出为空，则遍历已完成，返回true
若节点非空，则把左右子节点分别加入队列，继续循环取队列。
当遇到第一个子节点（左右都算）为空的节点时，置flag为true，表示这之后队列中的所有节点都不应再有子节点。






102. 二叉树的层序遍历
通过链表方式实现广度优先遍历，访问一个节点时，将其左右子节点加入到队列
由于输出是每行一个数组打印，因此浏览时需要记录当前层中节点个数，以控制数组创建时机






103. 二叉树的锯齿形层序遍历

与广度优先遍历类似，每行遍历完成后需要将偶数行数据顺序反转







105. 从前序与中序遍历序列构造二叉树

递归方式构造二叉树，使用Arrays.copyOfRange方便的创造子数组


41. 缺失的第一个正数a
非常巧妙的解法
题目中要求时间复杂度为O(N)，空间复杂度O(1)，想创建任何能存放N个元素的数据结构都会导致空间复杂度超出要求，
因此本题试图通过在原数组中进行特殊标记来记录访问状态

数组中一共N个元素，如果存在至少一个非正数或大于N的正数，则[1, N]这其中N个数字一定会有缺失。
非正数和大于N的数一样，其价值是相同的，都不需要关注，只需关注[1, N]这个范围内的数字
将[1, N]一一映射到[0, N-1]上，就可以通过数组坐标表示存在与否的状态，思路就是给所有元素值加上一个“负号”
最后遍历整个数组，所有位置上的元素，如果是负数，就说明这个元素的下标加一以后，存在于数组中
反之，如果出现了小于N+1的正数，则说明这个数加一以后不存在于数组中

解题步骤：
1.遍历数组，将所有小于等于0的元素都修改成N+1，此时数组中仅存在正整数
2.遍历数组，对于值为[1, N]范围内的元素K，在数组中的K-1位置标记一个负号
3.遍历数组，如果元素值为正数，则表示这个坐标(i)对应的元素值(i+1)没出现过，就是答案




199. 二叉树的右视图
注意：LeetCode的时间消耗排名和内训消耗排名不准确，不能作为判断时间复杂度、空间复杂的的标准

ArrayDeque和LinkedList的区别
执行用时：1 ms-.73%
内存消耗：40.1 MB-57.14%

题解：BFS逐层遍历二叉树，将每层最后一个节点的值记录下来即可



54. 螺旋矩阵
是一道数学题，主要难度是边界判断和计算旋转路线。




101. 对称二叉树
递归法，很容易



415. 字符串相加
涉及String和int相互转化，数字按照String按位从尾加到头部，完成后再使用str.reverse()进行反转




232. 用栈实现队列
使用两个栈，分别用于入栈缓存和出栈，
pop时，如果出栈为空，则将数据从入栈倒换至出栈，这样倒换一次顺序就实现了队列的先入先出

考虑泛型实现




112. 路径总和

看似简单，实则具有启发性
可以通过递归法进行DFS，也可以用队列实现BFS/栈实现DFS
值得认真写一写

思考本题和《113. 路径总和 II》有什么区别————解题思路没区别，只是II里需要再维护一个ArrayList记录答案

我用了四种方法：
1.回溯法（栈+递归)，实现DFS
2.栈+单次循环实现DFS
3.队列+单次循环实现BFS
4.递归实现DFS

这四种方法的时间复杂度都是O(N)，但实际执行时间各不相同，实际执行时间花费长短顺序：
1 > 2 = 3 > 4
实际执行占用的内存大小顺序：
1 > 4 > 2 = 3
可见使用回溯法的时间和空间开销都是最高的，比较不适用本题。

另外两种思路中：
使用栈（队列）的时间较长，但空间开销小
使用递归的执行时间较短，但空间开销大


剑指 Offer 09. 用两个栈实现队列
题目重复，不写了



56. 合并区间
经典的题目

先给二维数组排序，按照interval[0]升序，排序规则通过Arrays.sort(Comparator接口)实现
Arrays.sort()、Collections.sort()都支持这种自定义的排序操作
排序后的数组单次循环遍历，将数组中的元素依次加入存放结果的List中，每次只需判断是否需要和List中最后一个元素合并

最终结果，单次循环将List转化为二维数组





42. 接雨水
按列遍历，计算每一列能注水的高度。
每列能注水的高度取决于左右两侧最高那根柱子的高度，根据木桶原理，左右两侧最高柱子中的较低者决定了桶内水位高度

可以通过动态规划计算位置[i]左右两侧最高柱子的高度




34. 在排序数组中查找元素的第一个和最后一个位置
需要认真写一下二分查找算法



19. 删除链表的倒数第N个节点
第一次字节跳动面试的时候考了一道题，《寻找倒数第N个节点》，我没做对。

分两段遍历链表，
第一次先找到整数第N个节点作为end指针，此时head节点处的start指针相对于end指针来说就是倒数第N个
将start指针和end指针同时向后移动，当end指针走到链表尾时，start指针指向的节点就是倒数第N个。
如果需要删除，就要同时记录start之前的pre节点，然后做一次next指针操作。



151. 翻转字符串里的单词
String类的操作，可以用split(" ")以空格作为拆分条件，将拆分后的结果再按数组返序拼装
需要注意split函数返回的数组，会因为目标子串中存在多个连续空格而产生空字符串，在使用前需要进行判断





141. 环形链表
基础解法是通过HashSet记录每一个被访问过的节点，在遍历下一个节点时，如果Set里已经存在则表示有环，
如果遇到null就结束了说明没有环。耗时和空间复杂度都比较高。

更好的解法是“龟兔赛跑法”，设置一个快指针一个慢指针，快指针每次向后移动两个节点，慢指针每次向后移动一个节点
这使得快指针相对慢指针来说，每次都向后移动一个节点，当移动次数达到环内节点数量时，一定已经相遇过。
实际花费时间和空间都比方法一小很多。




142. 环形链表 II
与141.环形链表不同，本题需要返回链表环形节点，快慢指针相交的点未必是环形链表的入口。
需要数学公式进行计算，2*(x + y) = x + y + n，推导出x + y = n
快慢指针相遇后为A点，距离环形链表的入口已走过y，还差x，x同时也是环形链表入口距链表Head的距离。
因此，相遇后，将快指针定位到链表Head重新每次走一步，慢指针从相遇点每次走一步，再相遇即为换形链表的入口。



94. 二叉树的中序遍历（很重要）
递归法简单直接，好写不容易错。
迭代法就是通过循环完成原本的递归任务。
本质是上手工实现递归过程中保存数据的栈，然后让程序按照栈的存储顺序处理返回结果。

实现的写法挺奇怪的，我没有完全理解。
思路是只有出栈的时候才记录到输出列表中。



144. 二叉树的前序遍历
迭代法的实现比中序遍历简单很多，也更好理解。
通过栈实现，访问完根节点，右子节点先入栈，然后左子节点入栈。
每次循环出栈一个栈顶节点。


543. 二叉树的直径
使用迭代方法遍历二叉树时，DFS是通过栈实现的，BFS是通过队列。
DFS分为三种：前序、中序、后序，指根节点的被访问顺序，控制根节点、左右节点的入栈顺序可以实现三种顺序。

仅用一次后序DFS可以实现


104. 二叉树的最大深度
DFS递归法只需一行代码
BFS可以使用队列完成计算，每轮访问一层节点，直到队列为空表示没有新的追加节点。


2. 两数相加
链的访问，没啥难度。
注意最高位两数相加可能产生进位。


4. 寻找两个正序数组的中位数
主要注意中位数的计算可以是一个元素，也可以是两个元素之和取平均，
因此在寻找第(m+n)/2个元素时需要判断取几个元素出来。


82. 删除排序链表中的重复元素








